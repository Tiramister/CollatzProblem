# Collatz予想シミュレータ

本レポジトリは、「ハードウェア構成法2018」の課題で作成したコードを公開することを目的として作成された。


## はじめに

今回作成したコードは、完全に0から作成したものではない。特に[先人のレポジトリ](https://github.com/dmingn/HW_report_2017)は、boostとsorterの実装にてとても参考にさせていただいたことを先に述べておく。


## 開発環境

| 役割 | ツール |
| :---: | :---:|
| OS    | macOS mojave |
| ハード | MacBook Pro |
| コンパイラ | GHDL (http://ghdl.free.fr/) |
| 波形観察 | gtkwave (http://gtkwave.sourceforge.net/) |

mac環境でModelSimを入れるのは困難だったため、代替としてGHDLを用いた。
しかしGHDLには必要エレメント数、最高動作速度を求める機能はないため、それらは求めていない。


## VHDLディレクトリ

本課題で作成した回路を記述したVHDLのファイルがまとまっている。

### 各種回路

| ファイル名 | 内容 |
| :---: | :--- |
| collatz\_[version].vhdl | 入力に整数を与えると、(入力・最高値・ステップ数)の組を返す。各バージョンの違いは後述。 |
| sorter.vhdl | collatzが返す型の値を、最高値について上から4つ保持する。<br>新しい入力が来ると、最高値が同じものがあればステップ数を大きい方に更新、なければ最高値について降順にソートする。|
| ram.vhdl | collatz_ramにて使用。入力をindexとして、collatzが返した値を保持する。[DOULOS社が公開しているコード](https://www.doulos.com/knowhow/vhdl_designers_guide/models/simple_ram_model/)を元にしている。 |
| top.vhdl | 上の3つをまとめ、1から1023までの入力について最高値が高い順に上から４つを返す。 |

`top.vhdl`については、探索終了後の「ramに結果を記録するタイミング」と「collatzを初期化するタイミング」が上手く噛み合わず、結局分かりにくい記述になってしまった。

<br>

その他、以下のような補助ファイル、及びテストベンチ用回路も作成した。

| ファイル名 | 内容 |
| :---: | :--- |
| types.vhdl | 型を宣言。 |
| collatz_tb.vhdl | collatz系ファイルのテストベンチ。1から1023までの入力を流す。 |
| testbench.vhdl | top.vhdlのテストベンチ。クロックを流し込むだけ。 |

gtkwaveではrecordをそのままでは波形出力できないため、テストベンチファイルでは出力をバラしている。

### collatzの種類

`collatz_[version].vhdl`の`[version]`に、以下のバージョン名を入れたものが該当のソースファイル。ただし`collatz_tb.vhdl`は例外。

それぞれの処理内容と、使ったときの総クロック数は以下の通り。

| バージョン名 | 内容 | クロック数 |
| :---: | :--- | :---: |
| simple | 愚直解。「偶数なら2で割る、奇数なら3倍して1引く」を1ステップ/クロックで実行する。 | 65,400 |
| boost | バレルシフタによって、偶数のときに1クロック内で割れるだけ2で割ってしまう。 | 45,094 |
| ram | シミュレート中にramを参照して、探索済みの値になったらそこで終了して結果を返す。 | 9,301 |

バレルシフタでは結構速くなると思ったが、愚直解の7割程度にしかならなかったのは意外だった。

一方、ramは入力とその結果だけを記録したものだが、それでも10Kクロックを割るのは想像以上だった。
折り返し(途中で経過した値を遡ってramを埋める)は複雑すぎて実装できなかったが、実装できれば3Kクロックを割るだろうか。


## Cディレクトリ

上で作成した回路の処理をC言語で模倣したもの。VHDLを見る前にこちらから見ると、何をしているかがわかりやすいかもしれない。

ばらつきが大きかったので、10回の平均を取っている。

| バージョン名 | 平均クロック数 |
| :---: | :---: |
| simple | 971K |
| boost | 1,860K |
| ram | 576K |

boostについてはsimpleより遅くなっている。これはシフト幅を決めるための処理が短縮分を上回ったためと考えられる。

ramは流石に速いが、それでもVHDLに比べると改善の幅は小さい。VHDLではboostはramの20%程度のクロック数だが、Cでは31%程度になっている。この差は、レジスタへアクセスする際のオーバーヘッドによるものだと予想される。
